#!/usr/bin/env python3
"""
Generate ring of charge electric field visualization for POV-Ray rendering.

Copyright (C) 2007-2026 Indrek Mandre <indrek(at)mare.ee>
Licensed under the MIT License.

Creates:
1. A borderless field image (ring_field.png)
2. A POV-Ray scene file (ring_scene.pov)
3. A rendered image (ring_render.png)
"""

import sys
import os
import shutil
import subprocess
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
from mhfields import ring_electric_field


def generate_borderless_field_image(params, output_path, resolution=800):
    """Generate a borderless field image with known spatial extent."""
    R = params['R']
    Q = params['Q']

    margin = 1.0
    extent = R + margin
    # For a ring in XY plane at z=0, we visualize XZ plane (y=0)
    # x = radial direction, z = axial direction
    x_range = (-extent, extent)
    z_range = (-extent, extent)

    # Create grid
    n_x = resolution
    n_z = resolution

    x = np.linspace(x_range[0], x_range[1], n_x)
    z = np.linspace(z_range[0], z_range[1], n_z)
    X, Z = np.meshgrid(x, z)

    # Compute field
    # ring_electric_field takes (r, a, R, Q) where r=radial, a=axial
    print("Computing field...")
    r = np.abs(X.ravel())  # radial distance from axis
    a = Z.ravel()          # axial distance
    E_r, E_a = ring_electric_field(r, a, R, Q)

    # Flip radial component for negative x (other side of axis)
    E_r = np.where(X.ravel() < 0, -E_r, E_r)

    # Reshape to grid
    E_x = E_r.reshape(X.shape)  # radial -> x direction
    E_z = E_a.reshape(X.shape)  # axial -> z direction

    magnitude = np.sqrt(E_x**2 + E_z**2)

    # Cap value at 5cm from ring
    E_cap = ring_electric_field(R - 0.05, 0, R, Q)
    cap_value = float(np.sqrt(E_cap[0]**2 + E_cap[1]**2))
    magnitude = np.where(magnitude > cap_value, 0, magnitude)

    # Create borderless figure
    print("Generating image...")
    dpi = 100
    fig_width = n_x / dpi
    fig_height = n_z / dpi

    fig = plt.figure(figsize=(fig_width, fig_height), dpi=dpi)
    ax = fig.add_axes([0, 0, 1, 1])  # Full figure, no margins
    ax.axis('off')

    # Log-scale colormap
    mag_pos = np.where(magnitude > 0, magnitude, np.nan)
    vmin = np.nanpercentile(mag_pos, 5)
    vmax = np.nanpercentile(mag_pos, 95)
    if vmin <= 0:
        vmin = np.nanmin(mag_pos[mag_pos > 0])

    # Colored intensity
    ax.pcolormesh(x, z, magnitude, cmap='jet', norm=LogNorm(vmin=vmin, vmax=vmax), shading='auto')

    # Black contour lines
    levels = np.logspace(np.log10(vmin), np.log10(vmax), 15)
    ax.contour(x, z, magnitude, levels=levels, colors='black', linewidths=0.5)

    # White streamlines
    ax.streamplot(x, z, E_x, E_z, color='white', linewidth=0.8, density=1.5, arrowsize=0.8)

    ax.set_xlim(x_range)
    ax.set_ylim(z_range)
    ax.set_aspect('equal')

    plt.savefig(output_path, dpi=dpi, pad_inches=0, bbox_inches='tight')
    plt.close()

    print(f"Saved: {output_path}")
    print(f"  X range: {x_range}")
    print(f"  Z range: {z_range}")

    return x_range, z_range


def generate_povray_scene(params, x_range, z_range, image_path, output_path):
    """Generate POV-Ray scene file."""
    R = params['R']
    wire_radius = 0.04  # Visual radius of ring wire

    x_min, x_max = x_range
    z_min, z_max = z_range

    # In our field image:
    #   - horizontal axis = x (radial direction)
    #   - vertical axis = z (axial direction)
    #   - the plane is y=0
    #
    # In POV-Ray we want:
    #   - quad lying flat (horizontal table) in the y=0 plane
    #   - ring in XY plane at z=0 (so axis along Z in POV-Ray)
    #   - camera above looking down

    pov_content = f'''// Ring of charge electric field visualization
// Generated by ring_povray.py

#version 3.7;

global_settings {{
    assumed_gamma 1.0
    max_trace_level 5
}}

// Camera - top-down view with slight angle
// Looking down at the horizontal quad (table view)
camera {{
    location <-2.29, 5.08, -5.46>
    look_at <0, 0, 0>
    angle 60
    right x * image_width / image_height
}}

// Lighting from above
light_source {{
    <5, 20, -5>
    color rgb <1, 1, 1>
}}

light_source {{
    <-3, 15, 3>
    color rgb <0.6, 0.6, 0.6>
}}

// Gold material for ring (to distinguish from magnetic field chrome)
#declare GoldMaterial = material {{
    texture {{
        pigment {{ color rgb <0.9, 0.75, 0.3> }}
        finish {{
            ambient 0.1
            diffuse 0.4
            specular 0.8
            roughness 0.01
            reflection {{
                0.4
                metallic
            }}
        }}
    }}
}}

// The ring of charge - lies in XZ plane at y=0 (ring axis along Y)
// We rotate to match our coordinate system where axis is along Z
#declare Ring = torus {{
    {R:.6f}, {wire_radius:.6f}
    material {{ GoldMaterial }}
    // Ring initially in XZ plane with axis along Y
    // Rotate to put it in XY plane with axis along Z
    rotate <90, 0, 0>
}}

// Field visualization quad - horizontal (table) at y=-0.01
// Image horizontal axis (u) = x direction
// Image vertical axis (v) = z direction
box {{
    <{x_min:.4f}, -0.011, {z_min:.4f}>,
    <{x_max:.4f}, -0.01, {z_max:.4f}>

    texture {{
        pigment {{
            image_map {{
                png "{os.path.basename(image_path)}"
                interpolate 2
                map_type 0
            }}
            // Map image onto XZ plane
            // Image: horizontal=x, vertical=z
            // POV-Ray planar map: u=x, v=y initially
            // After rotate <90,0,0>: u=x, v=z
            rotate <90, 0, 0>
            scale <{x_max - x_min:.4f}, 1, {z_max - z_min:.4f}>
            translate <{x_min:.4f}, 0, {z_min:.4f}>
        }}
        finish {{
            ambient 1.0
            diffuse 0.0
            specular 0
            reflection 0
        }}
    }}
}}

object {{ Ring }}
'''

    with open(output_path, 'w') as f:
        f.write(pov_content)

    print(f"Saved: {output_path}")


if __name__ == '__main__':
    output_dir = os.path.dirname(os.path.abspath(__file__))

    # Ring parameters
    params = {
        'R': 1.0,     # Ring radius (m)
        'Q': 1e-9,    # Total charge (C) - 1 nC
    }

    print(f"Ring of charge: R = {params['R']} m, Q = {params['Q']*1e9:.1f} nC")

    image_path = os.path.join(output_dir, 'ring_field.png')
    if os.path.exists(image_path):
        print(f"Using existing: {image_path}")
        # Recompute ranges from params
        R = params['R']
        margin = 1.0
        extent = R + margin
        x_range = (-extent, extent)
        z_range = (-extent, extent)
    else:
        x_range, z_range = generate_borderless_field_image(params, image_path)

    pov_path = os.path.join(output_dir, 'ring_scene.pov')
    generate_povray_scene(params, x_range, z_range, image_path, pov_path)

    # Render with POV-Ray
    if shutil.which('povray') is None:
        print("\nError: POV-Ray is not installed.")
        print("Install with: sudo apt-get install povray")
        sys.exit(1)

    render_path = os.path.join(output_dir, 'ring_render.png')
    print("\nRendering with POV-Ray (2880x1620)...")
    result = subprocess.run(
        ['povray', '+W2880', '+H1620', '+A', '-D', f'+O{render_path}', pov_path],
        capture_output=True
    )
    if result.returncode != 0 or not os.path.exists(render_path):
        print("POV-Ray rendering failed")
        sys.exit(1)

    print(f"Saved: {render_path}")

    # Post-process with ImageMagick: make black transparent and trim
    if shutil.which('convert') is not None:
        print("Processing with ImageMagick (transparency + trim)...")
        result = subprocess.run(
            ['convert', render_path, '-fuzz', '5%', '-transparent', 'black', '-trim', '+repage', render_path],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            print(f"Processed: {render_path}")
        else:
            print("ImageMagick processing failed:", result.stderr)
    else:
        print("Note: Install ImageMagick for post-processing (sudo apt-get install imagemagick)")
